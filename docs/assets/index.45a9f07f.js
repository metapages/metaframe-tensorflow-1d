import{v as i,O as at,u as nt,l as w,i as it,A as T,I as ot,Q as rt,d as lt,M as ct,D as dt,a as ht,b as ut,c as gt,e as mt,B as D,y as f,f as pt,o as B,g as L,s as ft,h as yt,j as y,r as bt,k as wt,Z as P,P as xt,m as I,n as Et,p as St,T as J,q as vt,t as C,w as $,x as U,z as M,C as O,E as z,F as Tt,G as Dt,U as Mt,L as _t,S as At,H as kt,J as W,K as _,N as V,R as A,V as R,W as q,X as It,Y as Ct,_ as X,$ as Ot,a0 as zt,a1 as Nt,a2 as Ft,a3 as Ht,a4 as Z,a5 as jt,a6 as Bt,a7 as Lt}from"./vendor.9b98ab22.js";const Pt=[{name:"nocache",displayName:"Disable caching",type:"boolean",default:!1},{name:"hide_auto_help",displayName:"Hide automatic help",type:"boolean",default:!1}],Jt=()=>i(at,{options:Pt}),$t=({url:a})=>{const[t]=nt("options"),e=t&&t.hide_auto_help,[n,s]=w(it()?!1:!e),o=T(()=>{s(!n)},[n]);return a=a||`${window.location.origin}${window.location.pathname}README.md`,i(lt,null,i(ot,{verticalAlign:"top","aria-label":"Help",icon:i(rt,null),size:"lg",onClick:o,mr:"4"}),i(Ut,{url:a,isOpen:n,setOpen:s}))},Ut=({isOpen:a,setOpen:t,url:e})=>{const n=T(()=>{t(!a)},[t,a]),s=T(()=>{t(!1)},[t]),o=`https://metapages.github.io/metaframe-markdown/#?url=${e}`;return i(gt,{size:"full",placement:"top",onClose:n,isOpen:a,onOverlayClick:s},i(ct,null,i(dt,null,i(ht,{size:"lg",colorScheme:"blue.500",bg:"gray.100"}),i(ut,null,i("iframe",{width:"100%",height:"100%",src:o})))))},m=mt(a=>({messages:[],modelCount:-1,model:void 0,trainingDataSet:void 0,predictionInput:void 0,predictionOutput:void 0,currentlyTrainingDataHash:null,clearMessages:()=>a(t=>({messages:[]})),addMessage:t=>a(e=>({messages:e.messages.concat([t])})),setMessages:t=>a(e=>({messages:t})),setTrainingDataSet:t=>a(e=>({trainingDataSet:t})),updateModels:async()=>{const t=await Wt();a(e=>({modelCount:t}))},deleteModels:async()=>{await Vt(),a(t=>({modelCount:0}))},setModel:async t=>{a(e=>({model:t}))},setPredictionInput:async t=>{a(e=>({predictionInput:t}))},setPredictionOutput:async t=>{a(e=>({predictionOutput:t}))}})),Wt=async()=>{const a=await D.listModels();return Object.keys(a).length},Vt=async()=>{const a=await D.listModels(),t=Object.keys(a).map(e=>D.removeModel(e));try{await Promise.all(t)}catch(e){console.error(e)}},Rt=()=>{const a=m(s=>s.modelCount),t=m(s=>s.updateModels),e=m(s=>s.deleteModels),n=T(async()=>{e()},[e]);return f(()=>{(async()=>{await t()})()},[t]),i(pt,{isDisabled:a<=0,onClick:n},"Clear cache (",a>0?a:0," models)")},G=a=>{const t={};return Object.keys(a).forEach(e=>{a[e]&&(t[e]=new Float32Array(N(a[e])))}),t},qt=a=>(console.log("predictionDecode",a),{requestId:a.requestId,series:G(a.series)}),S="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",v=new Uint8Array(256);for(var k=0;k<S.length;k++)v[S.charCodeAt(k)]=k;function Y(a){let t=new Uint8Array(a),e,n=t.length,s="";for(e=0;e<n;e+=3)s+=S[t[e]>>2],s+=S[(t[e]&3)<<4|t[e+1]>>4],s+=S[(t[e+1]&15)<<2|t[e+2]>>6],s+=S[t[e+2]&63];return n%3==2?s=s.substring(0,s.length-1)+"=":n%3==1&&(s=s.substring(0,s.length-2)+"=="),s}function N(a){if(!a)throw new Error("base64decode string argument given");let t=a.length*.75,e=a.length,n,s=0,o,r,l,c;a[a.length-1]==="="&&(t--,a[a.length-2]==="="&&t--);var h=new ArrayBuffer(t),d=new Uint8Array(h);for(n=0;n<e;n+=4)o=v[a.charCodeAt(n)],r=v[a.charCodeAt(n+1)],l=v[a.charCodeAt(n+2)],c=v[a.charCodeAt(n+3)],d[s++]=o<<2|r>>4,d[s++]=(r&15)<<4|l>>2,d[s++]=(l&3)<<6|c&63;return h}/**
 * @license
 * Private wand license.
 * Currently very specific to gestures, need to loosen that up
 */const Xt=.7;class Q{constructor(t){this.data={},this.ranges={},this._labels=[],this._streams=[],this.shuffledTrainIndex=0,this.shuffledTestIndex=0,this.trainingIndices=new Uint32Array,this.testingIndices=new Uint32Array,this.bigFatDataArray=new Float32Array,this.bigFatLabelArray=new Uint8Array,this._timesteps=0,this.trainingDataJson=t}hash(){if(!this.trainingDataJson)throw"No trainingDataJson to hash";return B(this.trainingDataJson)}nextTrainBatch(t){return this.nextBatch(t,this.trainingIndices)}nextTestBatch(t){return this.nextBatch(t,this.testingIndices)}nextBatch(t,e){const n=new Float32Array(t*this.imageSize),s=new Uint8Array(t*this.numClasses);console.assert(this.numClasses>0);for(let l=0;l<t;l++){const c=e[l%e.length],h=c*this.imageSize,d=this.bigFatDataArray.slice(h,h+this.imageSize);n.set(d,l*this.imageSize);const g=c*this.numClasses,u=this.bigFatLabelArray.slice(g,g+this.numClasses);s.set(u,l*this.numClasses)}const o=L(n,[t,this.imageSize]),r=L(s,[t,this.numClasses]);return{xs:o,labels:r}}get classNames(){return this._labels}get gestureNames(){return this.classNames}get numClasses(){return this._labels.length}get imageWidth(){return this._streams.length}get width(){return this.imageWidth}get imageHeight(){return this.timeSteps}get height(){return this.imageHeight}get imageSize(){return this.imageWidth*this.imageHeight}get timeSteps(){return this._timesteps}get trainingExampleCount(){return this.trainingIndices.length}get testingExampleCount(){return this.testingIndices.length}allNonTimeValues(t){this.allNonTimeSensorStreams((e,n,s,o)=>{e.forEach((r,l)=>{t(r,l,e,n,s,o)})})}allSensorStreams(t){Object.keys(this.data).forEach(e=>{this.data[e].forEach((s,o)=>{const r=s.data;this._streams.forEach(l=>{t(r[l],l,o,e)})})})}allNonTimeSensorStreams(t){Object.keys(this.data).forEach(e=>{this.data[e].forEach((s,o)=>{const r=s.data;this._streams.forEach(l=>{l.endsWith("t")||t(r[l],l,o,e)})})})}allExamples(t){Object.keys(this.data).forEach(e=>{this.data[e].forEach((s,o)=>{const r=s.data;t(r,o,e)})})}allExamplesForLabel(t){return this.data[t]}getMaxValue(){let t=0;const e=n=>{t=Math.max(Math.abs(n),t)};return this.allNonTimeValues(e),t}normalize(){console.log("    normalizing...");const t=this._streams.filter(e=>!e.endsWith("t"));t.forEach(e=>this.ranges[e]={min:Number.MAX_VALUE,max:Number.MIN_VALUE,absmax:Number.MIN_VALUE}),this.allNonTimeSensorStreams((e,n,s,o)=>{e.forEach(r=>{this.ranges[n].min=Math.min(this.ranges[n].min,r),this.ranges[n].max=Math.max(this.ranges[n].max,r)})}),t.forEach(e=>this.ranges[e].absmax=Math.max(this.ranges[e].max,Math.abs(this.ranges[e].min))),this.allNonTimeSensorStreams((e,n,s,o)=>{const r=this.ranges[n].absmax;e.forEach((l,c)=>{e[c]=e[c]/r})}),console.log(`        this.ranges=${JSON.stringify(this.ranges)}`)}zeroTime(){console.log("    zeroing time..."),this.allExamples(t=>{const e=this._streams.filter(s=>s.endsWith("t"));let n=Number.MAX_VALUE;e.forEach(s=>{t[s].forEach((o,r)=>n=Math.min(n,o))}),e.forEach(s=>{t[s].forEach((o,r)=>{t[s][r]=o-n})})})}trimToLongestNonZeroGesture(){console.log("    getting longest non-default gesture...");let t=0,e=0;const n=this._streams.filter(s=>!s.endsWith("t"));this.allExamples((s,o,r)=>{if(!this.trainingDataJson.controlLabels||!this.trainingDataJson.controlLabels.includes(r)){let l=s[this._streams[0]].length-1;for(;l>=0&&!(n.filter(c=>s[c][l]!=0).length>0);l--);t=Math.max(t,l+1)}e=Math.max(e,s[this._streams[0]].length)}),console.log(`        [max=${t}] [maxAll=${e}]...trimming...`),this.allExamples((s,o,r)=>{this._streams.forEach(l=>{s[l]=s[l].slice(0,t)})}),e=0,this.allSensorStreams(s=>{e=Math.max(e,s.length)}),console.log(`        all arrays now [max=${e}]`)}extend(){console.log("    extending...");let t=0;const e=[];this.allSensorStreams(n=>{t=Math.max(t,n.length),n.forEach((s,o)=>{o!=0&&e.push(s-n[o-1])})}),this._timesteps=t,console.log(`        this.timeSteps=${this.timeSteps}`)}processPrediction(t){if(!t)throw"processExample: missing example";if(this._timesteps===0)throw"processPrediction but this._timesteps === 0";Object.keys(t).forEach(s=>{if(t[s].length>this._timesteps&&(t[s]=t[s].slice(0,this._timesteps)),t[s].length<this._timesteps){const o=new Float32Array(this._timesteps);o.set(t[s]),t[s]=o}}),Object.keys(t).forEach(s=>{const o=this.ranges[s].absmax;t[s].forEach((r,l,c)=>{c[l]=r/o})});const e=new Float32Array(1*this.imageSize);let n=0;return this._streams.forEach(s=>{const o=n*this.timeSteps;e.set(t[s],o),n++}),e}async load(){console.log(`Begin loading examples from ${this.trainingDataJson.examples.length} gestures and converting to float arrays...`),this.data={};const t=this.data;this._streams=[];const e={};console.log(this?.trainingDataJson?.examples[0]),this.trainingDataJson.examples.forEach(c=>{const h=c.label;t[h]||(t[h]=[]);const d=G(c.data.series);Object.keys(d).forEach(u=>e[u]=!0);const g={data:d,url:c.name||c.url};t[h].push(g)}),this._streams=Object.keys(e),this._streams.sort(),this._labels=Object.keys(this.data),this._labels.sort(),console.log(`labels: [  ${this._labels.join("  |  ")}  ]`),console.log("    done loading raw gesture data, begin preprocessing..."),this.trimToLongestNonZeroGesture(),this.normalize();const n=this.getMaxValue();if(console.log(`        normalizedMax=${n}`),n!=1)throw"Failed to normalize";this.zeroTime(),this.extend(),console.log("    converting to large combined float arrays...");const s=Object.keys(this.data).reduce((c,h)=>c+this.data[h].length,0);this.bigFatDataArray=new Float32Array(s*this.imageSize),this.bigFatLabelArray=new Uint8Array(s*this.numClasses),console.log(`        totalExampleCount=${s} imageSize=${this.imageSize} numClasses=${this.numClasses}`),console.log(`            width=${this.width} height=${this.height}`);let o=0;this.classNames.forEach((c,h)=>{this.data[c].forEach(g=>{this.bigFatLabelArray[o*this.numClasses+h]=1;const u=g.data;let b=0;this._streams.forEach(p=>{const F=o*this.imageSize+b*this.timeSteps;this.bigFatDataArray.set(u[p],F),b++}),o++})});const r=ft.createShuffledIndices(s),l=Math.floor(Xt*s);this.trainingIndices=r.slice(0,l),this.testingIndices=r.slice(l)}}/**
 * @license
 * Private wand license.
 */const Zt=32,Gt=10;class Yt{constructor(t){this.classNames=[],this._data=t,this.createModel()}get model(){return this._model}createModel(){const t=this._data;this.classNames=t.classNames,this._model=yt(),this._model.add(y.conv1d({filters:100,kernelSize:7,strides:1,activation:"relu",kernelInitializer:"varianceScaling",inputShape:[t.height,t.width]})),this._model.add(y.conv1d({filters:100,kernelSize:7,strides:1,activation:"relu"})),this._model.add(y.conv1d({filters:100,kernelSize:7,strides:1,activation:"relu"})),this._model.add(y.maxPooling1d({poolSize:3})),this._model.add(y.conv1d({filters:100,kernelSize:7,strides:1,activation:"relu"})),this._model.add(y.globalAveragePooling1d()),this._model.add(y.dropout({rate:.5})),y.flatten(),this._model.add(y.dense({units:t.classNames.length,activation:"softmax"})),this._model.summary();const e=bt.adam();return this._model.compile({optimizer:e,loss:"categoricalCrossentropy",metrics:["accuracy"]}),this._model}async train(){const t=this._data,e=["loss","val_loss","acc","val_acc"],n=document.getElementById("Training"),s=wt.show.fitCallbacks(n,e),o=t.trainingExampleCount*2,[r,l]=P(()=>{const u=t.nextTrainBatch(o);return[u.xs.reshape([o,t.imageHeight,t.imageWidth]),u.labels]}),c=t.testingExampleCount*2,[h,d]=P(()=>{const u=t.nextTestBatch(c);return[u.xs.reshape([c,t.imageHeight,t.imageWidth]),u.labels]}),g=await this.model.fit(r,l,{batchSize:Zt,validationData:[h,d],epochs:Gt,shuffle:!0,callbacks:s});return this.model,g}}const K=async a=>{const t=new Qt;await a.model.save(t);const e=Object.assign({},a);return e.model=t.modelJson,e};class Qt{constructor(t){this.modelJson=t}async save(t){const e={modelArtifactsInfo:{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology.byteLength,weightDataBytes:t.weightData.byteLength}};try{return this.modelJson=Object.assign({},t),this.modelJson.modelTopology=Y(t.modelTopology),this.modelJson.weightData=Y(t.weightData),e}catch(n){return e.errors=["{err}"],e}}async load(){console.log("JsonIOHandler.loading");const t=Object.assign({},this.modelJson);return t.modelTopology=N(this.modelJson.modelTopology),t.weightData=N(this.modelJson.weightData),console.log("JsonIOHandler.modelArtifacts",t),t}}const Kt=async(a,t)=>{if(!a)return[void 0,new Error("Asked to predict sample but no model loaded")];if(!t)return[void 0,new Error("Asked to predict but no input")];if(!t.series)return[void 0,new Error("Asked to predict but input lacks 'series' field")];const e=t.series,n=te(a,e),s=xt(n,[1,a.meta.prediction.imageHeight,a.meta.prediction.imageWidth]),o=a.model.predictOnBatch(s).dataSync();let r=0,l="",c;const h={};return a.meta.prediction.classNames.forEach((g,u)=>{h[g]=o[u],o[u]>r&&(r=o[u],l=g)}),l!=="_"&&h[l]<.45&&h._&&(c=`${l} -> _ because score < 0.45`,l="_"),[{prediction:l,predictions:h,requestId:t.requestId,modelHash:a.meta.training.hash,note:c},void 0]},te=(a,t)=>{if(!t)throw"processExample: missing example";if(!a)throw"processExample: missing model";Object.keys(t).forEach(o=>{o.endsWith("t")&&delete t[o]});const e=Object.keys(t);e.sort(),console.log("keys",e);const n=Math.max(a.meta.prediction.imageHeight,a.meta.prediction.imageWidth);e.forEach(o=>{if(t?.[o]?.length>n&&(t[o]=t[o].slice(0,n)),t?.[o]?.length<n){const r=new Float32Array(n);r.set(t[o]),t[o]=r}}),e.forEach(o=>{t[o].forEach((r,l,c)=>{c[l]=r/a.meta.training.ranges[o].absmax})});const s=new Float32Array(1*a.meta.prediction.imageWidth*a.meta.prediction.imageHeight);return e.forEach((o,r)=>{const l=r*n;s.set(t[o],l)}),s},ee=()=>{const a=I(),[t]=Et("nocache"),[e,n]=w(void 0),[s,o]=w(""),r=m(d=>d.setModel),l=m(d=>d.model);f(()=>{},[n]),f(()=>{const d=a?.inputs.training;if(d&&d!==n){const g=B(d);g!==s&&(o(g),n(d))}},[a.inputs,s,o,n]);const c=m(d=>d.updateModels),h=m(d=>d.setMessages);return f(()=>{if(!e||!e.examples||e.examples.length===0||!a?.setOutputs)return;const d={message:"Training",type:"info"},g=Object.keys(e.examples.reduce((b,p)=>(b[p.label]=!0,b),{}));if(g.length<2){const b={message:`Not enough data labels: [${g.join(", ")}]`,type:"warning"};h([d,b]);return}let u=!1;return(async()=>{h([d,{message:"loading data...",type:"info"}]);const p=new Q(e);if(await p.load(),u)return;h([d,{message:"\u2705 loaded data",type:"info"}]);const x=p.hash(),H={prediction:{classNames:p.classNames,imageHeight:p.imageHeight,imageWidth:p.imageWidth},training:{date:new Date,hash:x,ranges:p.ranges}};let E;if(!t){const et=await D.listModels();if(u)return;if(et[`indexeddb://${x}`]){const st=await St(`indexeddb://${x}`);if(u)return;E={model:st,meta:H},h([d,{message:`Model ready (cached) ${x.substr(0,10)}`,type:"success"}]),r(E);return}}h([d,{message:"training...",type:"warning"}]);const j=new Yt(p);if(await j.train(),u)return;h([d,{message:"\u2705 Trained",type:"warning"}]),E={model:j.model,meta:H},t||(await E.model.save(`indexeddb://${x}`),c()),r(E);const tt=await K(E);a.setOutputs({model:tt}),h([d,{message:`\u2705 Model ready ${x.substr(0,10)}`,type:"success"}])})(),()=>{u=!0}},[e,t,r,a?.setOutputs]),f(()=>{l&&a?.setOutputs&&(async()=>{const d=await K(l);a.setOutputs({model:d})})()},[l,a?.setOutputs]),i("div",null,i(Rt,null),i("div",{id:"Training"}))},se=()=>{const a=I(),t=m(c=>c.model),[e,n]=w(void 0),[s,o]=w(void 0),[r,l]=w(void 0);return f(()=>{console.log("metaframeObject.inputs",a.inputs)},[a.inputs]),f(()=>{const c=a?.inputs?.prediction;if(c&&c!==e){n(c);const h=qt(c);o(h)}},[a.inputs,e,n,o]),f(()=>{!s||!t||!a?.setOutputs||(async()=>{const[c,h]=await Kt(t,s);a.setOutputs({prediction:c,error:h?.message}),l(c)})()},[s,t,l,a.setOutputs]),i("div",null,i(O,{status:r?.prediction?"success":"info"},i(z,null),r?r.prediction:"...waiting for data"),r?.note?i(O,{status:"warning"},i(z,null),r?.note):null,i(J,{variant:"simple"},i(vt,null,i(C,null,i($,null,"Label"),i($,null,"Score"))),i(U,null,r?Object.keys(r.predictions).sort(c=>r.predictions[c]).map(c=>i(C,null,i(M,null,c),i(M,{isNumeric:!0},r.predictions[c]))):null)))},ae=()=>{const a=m(t=>t.messages);return i(At,{spacing:3},a.map((t,e)=>i(O,{key:e,status:t.type?t.type:"info"},i(Tt,{mr:2},t.message),i(z,null),i(Dt,null,i(Mt,null,t.messages?t.messages.map((n,s)=>i(_t,{key:s},n)):null)))))};var he='.uplot, .uplot *, .uplot *::before, .uplot *::after {box-sizing: border-box;}.uplot {font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";line-height: 1.5;width: min-content;}.u-title {text-align: center;font-size: 18px;font-weight: bold;}.u-wrap {position: relative;user-select: none;}.u-over, .u-under {position: absolute;}.u-under {overflow: hidden;}.uplot canvas {display: block;position: relative;width: 100%;height: 100%;}.u-legend {font-size: 14px;margin: auto;text-align: center;}.u-inline {display: block;}.u-inline * {display: inline-block;}.u-inline tr {margin-right: 16px;}.u-legend th {font-weight: 600;}.u-legend th > * {vertical-align: middle;display: inline-block;}.u-legend .u-marker {width: 1em;height: 1em;margin-right: 4px;background-clip: padding-box !important;}.u-inline.u-live th::after {content: ":";vertical-align: middle;}.u-inline:not(.u-live) .u-value {display: none;}.u-series > * {padding: 4px;}.u-series th {cursor: pointer;}.u-legend .u-off > * {opacity: 0.3;}.u-select {background: rgba(0,0,0,0.07);position: absolute;pointer-events: none;}.u-cursor-x, .u-cursor-y {position: absolute;left: 0;top: 0;pointer-events: none;will-change: transform;z-index: 100;}.u-hz .u-cursor-x, .u-vt .u-cursor-y {height: 100%;border-right: 1px dashed #607D8B;}.u-hz .u-cursor-y, .u-vt .u-cursor-x {width: 100%;border-bottom: 1px dashed #607D8B;}.u-cursor-pt {position: absolute;top: 0;left: 0;border-radius: 50%;border: 0 solid;pointer-events: none;will-change: transform;z-index: 100;/*this has to be !important since we set inline "background" shorthand */background-clip: padding-box !important;}.u-select.u-off, .u-cursor-x.u-off, .u-cursor-y.u-off, .u-cursor-pt.u-off {display: none;}';const ne=({example:a})=>{const t=Object.keys(a.data),e=[Array.from(Array(a.data[t[0]].length).keys()),...t.map(s=>Array.from(a.data[s]))];return i("div",null,i(kt,{options:{width:400,height:100,pxAlign:!1,cursor:{show:!1},legend:{show:!1},scales:{x:{time:!1}},axes:[{show:!1},{show:!1}],series:[{},{stroke:"#FF6D6D"},{stroke:"#FFA56D"},{stroke:"#D5B93B"},{stroke:"#8089FF"},{stroke:"#AA80FF"},{stroke:"#80BFFF"}]},data:e}))},ie=()=>{const a=m(n=>n.trainingDataSet),[t,e]=w();return f(()=>{if(!a)return;let n=!1;return(async()=>{const s=new Q(a);await s.load(),!n&&e(s)})(),()=>{n=!0}},[a]),f(()=>{},[t]),i(R,{isLazy:!0,orientation:"horizontal"},i(V,null,t?t._labels.map((n,s)=>i(A,{key:s},n)):[]),i(W,null,t?t._labels.map((n,s)=>i(_,{p:4,key:s},i(oe,{label:n,trainingData:t}))):[]))},oe=({label:a,trainingData:t})=>{const e=t.allExamplesForLabel(a);return e[0]&&Object.keys(e[0].data).sort(),i("div",null,i(q,{size:"small"},"Total: ",e.length),i(J,{variant:"simple"},i(U,null,e.map((n,s)=>i(C,{key:s},i(M,null,n.url),i(M,null,i(ne,{example:n})))))))},re=()=>{const a=It(["red.50","teal.50","blue.50"],["red.900","teal.900","blue.900"]),[t,e]=Ct("tab",0),n=a[t];return i(Ft,{columns:1,spacing:10},i(X,null,i(q,{size:"md"},i(Ot,{href:"https://www.tensorflow.org/js",isExternal:!0,mr:"2"},i(zt,null)," Tensorflow 1D"),"convolutional neural net trainer/predictor"),i(Nt,null),i($t,null),i(Jt,null)),i(X,null,i(ae,null)),i(Ht,null,i(R,{isLazy:!0,isFitted:!0,onChange:e,bg:n},i(V,null,i(A,null,"Visualize training"),i(A,null,"Train"),i(A,null,"Predict")),i(W,{p:"1rem"},i(_,null,i(ie,null)),i(_,null,i(ee,null)),i(_,null,i(se,null))))))},le=()=>i("div",null,i(re,null)),ce=()=>{const a=I(),t=m(n=>n.setTrainingDataSet),e=m(n=>n.setPredictionInput);return f(()=>{if(!a.metaframe)return;const n=[];return n.push(a.metaframe.onInput("training",s=>{s&&t(s)})),n.push(a.metaframe.onInput("prediction",s=>{s&&e(s)})),()=>{for(;n.length>0;)n.pop()()}},[a.metaframe,t]),i(le,null)};Z.config({driver:Z.INDEXEDDB,name:"metaframe-predictor",version:1,storeName:"models",description:"Stores tensorflow models locally"}),jt(i(Lt,null,i(Bt,null,i(ce,null))),document.getElementById("root"));
//# sourceMappingURL=index.45a9f07f.js.map
