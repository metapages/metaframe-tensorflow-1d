import{v as o,O as G,u as Y,l as E,i as Q,A as M,I as K,Q as tt,d as et,M as st,D as at,a as nt,b as it,c as ot,e as rt,B as A,y as b,f as lt,o as O,g as z,s as ct,h as dt,j as p,r as ht,k as ut,Z as B,P as mt,m as j,n as gt,p as pt,T as ft,q as yt,t as J,w as L,x as bt,z as P,C as D,E as v,F as wt,G as xt,U as Et,L as _t,S as Tt,H as Mt,J as At,K as N,N as St,R as Dt,V as vt,W as Ct,X as It,Y as kt,_ as Ht,$ as Ot,a0 as F,a1 as zt,a2 as $,a3 as W,a4 as Bt,a5 as jt,a6 as Jt}from"./vendor.6557a272.js";const Lt=[{name:"nocache",displayName:"Disable caching",type:"boolean",default:!1},{name:"hide_auto_help",displayName:"Hide automatic help",type:"boolean",default:!1}],Pt=()=>o(G,{options:Lt}),Nt=({url:a})=>{const[t]=Y("options"),e=t&&t.hide_auto_help,[n,s]=E(Q()?!1:!e),i=M(()=>{s(!n)},[n]);return a=a||`${window.location.origin}${window.location.pathname}README.md`,o(et,null,o(K,{verticalAlign:"top","aria-label":"Help",icon:o(tt,null),size:"lg",onClick:i,mr:"4"}),o(Ft,{url:a,isOpen:n,setOpen:s}))},Ft=({isOpen:a,setOpen:t,url:e})=>{const n=M(()=>{t(!a)},[t,a]),s=M(()=>{t(!1)},[t]),i=`https://metapages.github.io/metaframe-markdown/#?url=${e}`;return o(ot,{size:"full",placement:"top",onClose:n,isOpen:a,onOverlayClick:s},o(st,null,o(at,null,o(nt,{size:"lg",colorScheme:"blue.500",bg:"gray.100"}),o(it,null,o("iframe",{width:"100%",height:"100%",src:i})))))},f=rt(a=>({messages:[],modelCount:-1,model:void 0,prediction:void 0,currentlyTrainingDataHash:null,clearMessages:()=>a(t=>({messages:[]})),addMessage:t=>a(e=>({messages:e.messages.concat([t])})),setMessages:t=>a(e=>({messages:t})),setTrainingDataHash:t=>a(e=>({currentlyTrainingDataHash:t})),updateModels:async()=>{const t=await $t();a(e=>({modelCount:t}))},deleteModels:async()=>{await Wt(),a(t=>({modelCount:0}))},setModel:async t=>{a(e=>({model:t}))},setPrediction:async t=>{a(e=>({prediction:t}))}})),$t=async()=>{const a=await A.listModels();return Object.keys(a).length},Wt=async()=>{const a=await A.listModels(),t=Object.keys(a).map(e=>A.removeModel(e));try{await Promise.all(t)}catch(e){console.error(e)}},Vt=()=>{const a=f(s=>s.modelCount),t=f(s=>s.updateModels),e=f(s=>s.deleteModels),n=M(async()=>{e()},[e]);return b(()=>{(async()=>{await t()})()},[t]),o(lt,{isDisabled:a<=0,onClick:n},"Clear cache (",a>0?a:0," models)")},V=a=>{const t={};return Object.keys(a).forEach(e=>t[e]=new Float32Array(C(a[e]))),t},Ut=a=>({requestId:a.requestId,series:V(a.series)}),_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",T=new Uint8Array(256);for(var S=0;S<_.length;S++)T[_.charCodeAt(S)]=S;function U(a){let t=new Uint8Array(a),e,n=t.length,s="";for(e=0;e<n;e+=3)s+=_[t[e]>>2],s+=_[(t[e]&3)<<4|t[e+1]>>4],s+=_[(t[e+1]&15)<<2|t[e+2]>>6],s+=_[t[e+2]&63];return n%3==2?s=s.substring(0,s.length-1)+"=":n%3==1&&(s=s.substring(0,s.length-2)+"=="),s}function C(a){if(!a)throw new Error("base64decode string argument given");let t=a.length*.75,e=a.length,n,s=0,i,l,r,c;a[a.length-1]==="="&&(t--,a[a.length-2]==="="&&t--);var h=new ArrayBuffer(t),d=new Uint8Array(h);for(n=0;n<e;n+=4)i=T[a.charCodeAt(n)],l=T[a.charCodeAt(n+1)],r=T[a.charCodeAt(n+2)],c=T[a.charCodeAt(n+3)],d[s++]=i<<2|l>>4,d[s++]=(l&15)<<4|r>>2,d[s++]=(r&3)<<6|c&63;return h}/**
 * @license
 * Private wand license.
 * Currently very specific to gestures, need to loosen that up
 */const Rt=.7;class qt{constructor(t){this.data={},this._labels=[],this._streams=[],this.shuffledTrainIndex=0,this.shuffledTestIndex=0,this.trainingIndices=new Uint32Array,this.testingIndices=new Uint32Array,this.bigFatDataArray=new Float32Array,this.bigFatLabelArray=new Uint8Array,this._timesteps=0,this._maxAbsoluteValue=0,this.trainingDataJson=t}hash(){if(!this.trainingDataJson)throw"No trainingDataJson to hash";return O(this.trainingDataJson)}nextTrainBatch(t){return this.nextBatch(t,this.trainingIndices)}nextTestBatch(t){return this.nextBatch(t,this.testingIndices)}nextBatch(t,e){const n=new Float32Array(t*this.imageSize),s=new Uint8Array(t*this.numClasses);console.assert(this.numClasses>0);for(let r=0;r<t;r++){const c=e[r%e.length],h=c*this.imageSize,d=this.bigFatDataArray.slice(h,h+this.imageSize);n.set(d,r*this.imageSize);const m=c*this.numClasses,u=this.bigFatLabelArray.slice(m,m+this.numClasses);s.set(u,r*this.numClasses)}const i=z(n,[t,this.imageSize]),l=z(s,[t,this.numClasses]);return{xs:i,labels:l}}get classNames(){return this._labels}get gestureNames(){return this.classNames}get numClasses(){return this._labels.length}get imageWidth(){return this._streams.length}get width(){return this.imageWidth}get imageHeight(){return this.timeSteps}get height(){return this.imageHeight}get imageSize(){return this.imageWidth*this.imageHeight}get timeSteps(){return this._timesteps}get trainingExampleCount(){return this.trainingIndices.length}get testingExampleCount(){return this.testingIndices.length}allNonTimeValues(t){this.allNonTimeSensorStreams((e,n,s,i)=>{e.forEach((l,r)=>{t(l,r,e,n,s,i)})})}allSensorStreams(t){Object.keys(this.data).forEach(e=>{this.data[e].forEach((s,i)=>{const l=s.data;this._streams.forEach(r=>{t(l[r],r,i,e)})})})}allNonTimeSensorStreams(t){Object.keys(this.data).forEach(e=>{this.data[e].forEach((s,i)=>{const l=s.data;this._streams.forEach(r=>{r.endsWith("t")||t(l[r],r,i,e)})})})}allExamples(t){Object.keys(this.data).forEach(e=>{this.data[e].forEach((s,i)=>{const l=s.data;t(l,i,e)})})}getMaxValue(){let t=0;const e=n=>{t=Math.max(Math.abs(n),t)};return this.allNonTimeValues(e),t}normalize(){console.log("    normalizing...");let t=this.getMaxValue();this._maxAbsoluteValue=t,console.log(`        max=${t}`),this.allNonTimeValues((e,n,s)=>{s[n]=e/t})}zeroTime(){console.log("    zeroing time..."),this.allExamples(t=>{const e=this._streams.filter(s=>s.endsWith("t"));let n=Number.MAX_VALUE;e.forEach(s=>{t[s].forEach(i=>n=Math.min(n,i))}),e.forEach(s=>{t[s].forEach((i,l)=>{t[s][l]=i-n})})})}trimToLongestNonZeroGesture(){console.log("    getting longest non-default gesture...");let t=0,e=0;const n=this._streams.filter(s=>!s.endsWith("t"));this.allExamples((s,i,l)=>{if(l!="_"){let r=s[this._streams[0]].length-1;for(;r>=0&&!(n.filter(c=>s[c][r]!=0).length>0);r--);t=Math.max(t,r+1)}e=Math.max(e,s[this._streams[0]].length)}),console.log(`        [max=${t}] [maxAll=${e}]...trimming...`),this.allExamples((s,i,l)=>{this._streams.forEach(r=>{s[r]=s[r].slice(0,t)})}),e=0,this.allSensorStreams(s=>{e=Math.max(e,s.length)}),console.log(`        all arrays now [max=${e}]`)}extend(){console.log("    extending...");let t=0;const e=[];this.allSensorStreams(n=>{t=Math.max(t,n.length),n.forEach((s,i)=>{i!=0&&e.push(s-n[i-1])})}),this._timesteps=t,console.log(`        this.timeSteps=${this.timeSteps}`)}processPrediction(t){if(!t)throw"processExample: missing example";if(this._timesteps===0)throw"processPrediction but this._timesteps === 0";Object.keys(t).forEach(s=>{if(t[s].length>this._timesteps&&(t[s]=t[s].slice(0,this._timesteps)),t[s].length<this._timesteps){const i=new Float32Array(this._timesteps);i.set(t[s]),t[s]=i}}),Object.keys(t).forEach(s=>{t[s].forEach((i,l,r)=>{r[l]=i/this._maxAbsoluteValue})});const e=new Float32Array(1*this.imageSize);let n=0;return this._streams.forEach(s=>{const i=n*this.timeSteps;e.set(t[s],i),n++}),e}async load(){console.log(`Begin loading examples from ${this.trainingDataJson.examples.length} gestures and converting to float arrays...`),this.data={};const t=this.data;this._streams=[];const e={};this.trainingDataJson.examples.forEach(c=>{const h=c.label;t[h]||(t[h]=[]);const d=V(c.data.series);Object.keys(d).forEach(u=>e[u]=!0);const m={data:d,url:c.name||c.url};t[h].push(m)}),this._streams=Object.keys(e),this._streams.sort(),this._labels=Object.keys(this.data),this._labels.sort(),console.log(`labels: [  ${this._labels.join("  |  ")}  ]`),console.log("    done loading raw gesture data, begin preprocessing..."),this.trimToLongestNonZeroGesture(),this.normalize();const n=this.getMaxValue();if(console.log(`        normalizedMax=${n}`),n!=1)throw"Failed to normalize";this.zeroTime(),this.extend(),console.log("    converting to large combined float arrays...");const s=Object.keys(this.data).reduce((c,h)=>c+this.data[h].length,0);this.bigFatDataArray=new Float32Array(s*this.imageSize),this.bigFatLabelArray=new Uint8Array(s*this.numClasses),console.log(`        totalExampleCount=${s} imageSize=${this.imageSize} numClasses=${this.numClasses}`),console.log(`            width=${this.width} height=${this.height}`);let i=0;this.classNames.forEach((c,h)=>{this.data[c].forEach(m=>{this.bigFatLabelArray[i*this.numClasses+h]=1;const u=m.data;let y=0;this._streams.forEach(g=>{const I=i*this.imageSize+y*this.timeSteps;this.bigFatDataArray.set(u[g],I),y++}),i++})});const l=ct.createShuffledIndices(s),r=Math.floor(Rt*s);this.trainingIndices=l.slice(0,r),this.testingIndices=l.slice(r)}}/**
 * @license
 * Private wand license.
 */const Zt=32,Xt=10;class Gt{constructor(t){this.classNames=[],this._data=t,this.createModel()}get model(){return this._model}createModel(){const t=this._data;this.classNames=t.classNames,this._model=dt(),this._model.add(p.conv1d({filters:100,kernelSize:7,strides:1,activation:"relu",kernelInitializer:"varianceScaling",inputShape:[t.height,t.width]})),this._model.add(p.conv1d({filters:100,kernelSize:7,strides:1,activation:"relu"})),this._model.add(p.conv1d({filters:100,kernelSize:7,strides:1,activation:"relu"})),this._model.add(p.maxPooling1d({poolSize:3})),this._model.add(p.conv1d({filters:100,kernelSize:7,strides:1,activation:"relu"})),this._model.add(p.globalAveragePooling1d()),this._model.add(p.dropout({rate:.5})),p.flatten(),this._model.add(p.dense({units:t.classNames.length,activation:"softmax"})),this._model.summary();const e=ht.adam();return this._model.compile({optimizer:e,loss:"categoricalCrossentropy",metrics:["accuracy"]}),this._model}async train(){const t=this._data,e=["loss","val_loss","acc","val_acc"],n=document.getElementById("Training"),s=ut.show.fitCallbacks(n,e),i=t.trainingExampleCount*2,[l,r]=B(()=>{const u=t.nextTrainBatch(i);return[u.xs.reshape([i,t.imageHeight,t.imageWidth]),u.labels]}),c=t.testingExampleCount*2,[h,d]=B(()=>{const u=t.nextTestBatch(c);return[u.xs.reshape([c,t.imageHeight,t.imageWidth]),u.labels]}),m=await this.model.fit(l,r,{batchSize:Zt,validationData:[h,d],epochs:Xt,shuffle:!0,callbacks:s});return this.model,m}}const R=async a=>{const t=new Yt;await a.model.save(t);const e=Object.assign({},a);return e.model=t.modelJson,e};class Yt{constructor(t){this.modelJson=t}async save(t){const e={modelArtifactsInfo:{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology.byteLength,weightDataBytes:t.weightData.byteLength}};try{return this.modelJson=Object.assign({},t),this.modelJson.modelTopology=U(t.modelTopology),this.modelJson.weightData=U(t.weightData),e}catch(n){return e.errors=["{err}"],e}}async load(){console.log("JsonIOHandler.loading");const t=Object.assign({},this.modelJson);return t.modelTopology=C(this.modelJson.modelTopology),t.weightData=C(this.modelJson.weightData),console.log("JsonIOHandler.modelArtifacts",t),t}}const Qt=async(a,t)=>{if(!a)return[void 0,new Error("Asked to predict sample but no model loaded")];if(!t)return[void 0,new Error("Asked to predict but no input")];if(!t.series)return[void 0,new Error("Asked to predict but input lacks 'series' field")];const e=t.series,n=Kt(a,e),s=mt(n,[1,a.meta.prediction.imageHeight,a.meta.prediction.imageWidth]),i=a.model.predictOnBatch(s).dataSync();let l=0,r="",c;const h={};return a.meta.prediction.classNames.forEach((m,u)=>{h[m]=i[u],i[u]>l&&(l=i[u],r=m)}),r!=="_"&&h[r]<.45&&h._&&(c=`${r} -> _ because score < 0.45`,r="_"),[{prediction:r,predictions:h,requestId:t.requestId,modelHash:a.meta.training.trainingDataHash,note:c},void 0]},Kt=(a,t)=>{if(!t)throw"processExample: missing example";if(!a)throw"processExample: missing model";Object.keys(t).forEach(i=>{i.endsWith("t")&&delete t[i]});const e=Object.keys(t);e.sort();const n=Math.max(a.meta.prediction.imageHeight,a.meta.prediction.imageWidth);e.forEach(i=>{if(t?.[i]?.length>n&&(t[i]=t[i].slice(0,n)),t?.[i]?.length<n){const l=new Float32Array(n);l.set(t[i]),t[i]=l}}),e.forEach(i=>{t[i].forEach((l,r,c)=>{c[r]=l/a.meta.prediction.maxAbsoluteRawValue})});const s=new Float32Array(1*a.meta.prediction.imageWidth*a.meta.prediction.imageHeight);return e.forEach((i,l)=>{const r=l*n;s.set(t[i],r)}),s},te=()=>{const a=j(),[t]=gt("nocache"),[e,n]=E(void 0),[s,i]=E(""),l=f(d=>d.setModel),r=f(d=>d.model);b(()=>{},[n]),b(()=>{const d=a?.inputs.training;if(d&&d!==n){const m=O(d);m!==s&&(i(m),n(d))}},[a.inputs,s,i,n]);const c=f(d=>d.updateModels),h=f(d=>d.setMessages);return b(()=>{if(!e||!e.examples||e.examples.length===0||!a?.setOutputs)return;const d={message:"Training",type:"info"},m=Object.keys(e.examples.reduce((y,g)=>(y[g.label]=!0,y),{}));if(m.length<2){const y={message:`Not enough data labels: [${m.join(", ")}]`,type:"warning"};h([d,y]);return}let u=!1;return(async()=>{h([d,{message:"loading data...",type:"info"}]);const g=new qt(e);if(await g.load(),u)return;h([d,{message:"\u2705 loaded data",type:"info"}]);const w=g.hash(),k={prediction:{classNames:g.classNames,imageHeight:g.imageHeight,imageWidth:g.imageWidth,maxAbsoluteRawValue:g._maxAbsoluteValue},training:{date:new Date,trainingDataHash:w}};let x;if(!t){const Z=await A.listModels();if(u)return;if(Z[`indexeddb://${w}`]){const X=await pt(`indexeddb://${w}`);if(u)return;x={model:X,meta:k},h([d,{message:`Model ready (cached) ${w.substr(0,10)}`,type:"success"}]),l(x);return}}h([d,{message:"training...",type:"warning"}]);const H=new Gt(g);if(await H.train(),u)return;h([d,{message:"\u2705 Trained",type:"warning"}]),x={model:H.model,meta:k},t||(await x.model.save(`indexeddb://${w}`),c()),l(x);const q=await R(x);a.setOutputs({model:q}),h([d,{message:`\u2705 Model ready ${w.substr(0,10)}`,type:"success"}])})(),()=>{u=!0}},[e,t,l,a?.setOutputs]),b(()=>{r&&a?.setOutputs&&(async()=>{const d=await R(r);a.setOutputs({model:d})})()},[r,a?.setOutputs]),o("div",null,o(Vt,null),o("div",{id:"Training"}))},ee=()=>{const a=j(),t=f(c=>c.model),[e,n]=E(void 0),[s,i]=E(void 0),[l,r]=E(void 0);return b(()=>{const c=a?.inputs?.prediction;if(c&&c!==e){n(c);const h=Ut(c);i(h)}},[a.inputs,e,n,i]),b(()=>{!s||!t||!a?.setOutputs||(async()=>{const[c,h]=await Qt(t,s);a.setOutputs({prediction:c,error:h?.message}),r(c)})()},[s,t,r,a.setOutputs]),o("div",null,o(D,{status:l?.prediction?"success":"info"},o(v,null),l?l.prediction:"...waiting for data"),l?.note?o(D,{status:"warning"},o(v,null),l?.note):null,o(ft,{variant:"simple"},o(yt,null,o(J,null,o(L,null,"Label"),o(L,null,"Score"))),o(bt,null,l?Object.keys(l.predictions).sort(c=>l.predictions[c]).map(c=>o(J,null,o(P,null,c),o(P,{isNumeric:!0},l.predictions[c]))):null)))},se=()=>{const a=f(t=>t.messages);return o(Tt,{spacing:3},a.map((t,e)=>o(D,{key:e,status:t.type?t.type:"info"},o(wt,{mr:2},t.message),o(v,null),o(xt,null,o(Et,null,t.messages?t.messages.map((n,s)=>o(_t,{key:s},n)):null)))))},ae=()=>{const a=Mt(["red.50","teal.50","blue.50"],["red.900","teal.900","blue.900"]),[t,e]=At("tab",0),n=a[t];return o(It,{columns:1,spacing:10},o(N,null,o(St,{size:"md"},o(Dt,{href:"https://www.tensorflow.org/js",isExternal:!0,mr:"2"},o(vt,null)," Tensorflow 1D"),"convolutional neural net trainer/predictor"),o(Ct,null),o(Nt,null),o(Pt,null)),o(N,null,o(se,null)),o(kt,null,o(Ht,{isFitted:!0,onChange:e,bg:n},o(Ot,null,o(F,null,"Train"),o(F,null,"Predict")),o(zt,{p:"1rem"},o($,null,o(te,null)),o($,null,o(ee,null))))))},ne=()=>o("div",null,o(ae,null)),ie=()=>o(ne,null);W.config({driver:W.INDEXEDDB,name:"metaframe-predictor",version:1,storeName:"models",description:"Stores tensorflow models locally"}),Bt(o(Jt,null,o(jt,null,o(ie,null))),document.getElementById("root"));
//# sourceMappingURL=index.51198575.js.map
